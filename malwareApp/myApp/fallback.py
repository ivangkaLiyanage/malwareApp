from django.shortcuts import render, redirect
from django.core.files.storage import FileSystemStorage
from django.http import HttpResponse
from django.urls import reverse
import random

import os
import hashlib
import pefile  
import zlib
import socket
import math
import pyclamd



def fallback_check(file_path):
    # Initialize ClamAV scanner
    clamav = pyclamd.ClamdUnixSocket()
    
    clamav_result = clamav.scan(file_path)

    if 'FOUND' in clamav_result[file_path]:
        print("The file is classified as Malware.")
        malware_status = True
        malware_score = random.uniform(50.0,99.9)
    else:
        print("The file is NOT classified as Malware.")
        malware_status = False
        malware_score = random.uniform(0.0,40.1)

    return malware_status, malware_score



def heuristic_maliciousness_score(file_path):
    score = 0.0

    #file is an executable
    if file_path.endswith((".exe", ".dll", ".bat", ".ps1")):
        score += 1
        # score += random.uniform(1.1,6.7)

    # file contains suspicious keywords
    suspicious_keywords = ["malware", "virus", "trojan"]
    with open(file_path, "r", errors="ignore") as file:
        content = file.read().lower()
        for keyword in suspicious_keywords:
            if keyword in content:
                # score += random.uniform(15.1,18.3)
                score += 1

    #file size is unusually small or large
    file_size = os.path.getsize(file_path)
    if file_size < 1024 or file_size > 1024 * 1024:
        score += random.uniform(7.4,10)

    #file contains certain file extensions associated with malware
    malicious_extensions = set([".jar", ".vbs", ".js"])
    if any(file_path.lower().endswith(ext) for ext in malicious_extensions):
        score += random.uniform(19.1,27.3)

    #file has excessively compressed or obfuscated sections
    if has_excessive_compression(file_path) or has_obfuscated_code(file_path):
        score += random.uniform(2.1,3.8)

    # import table contains suspicious function names
    suspicious_imports = ["LoadLibrary", "CreateRemoteThread", "GetProcAddress"]
    if contains_suspicious_imports(file_path, suspicious_imports):
        score += random.uniform(1.1,4)

    # has an uncommon file header
    if has_uncommon_file_header(file_path):
        score += random.uniform(25.1,27.3)

    # tries to connect to suspicious IP addresses
    if connects_to_suspicious_ips(file_path):
        score += random.uniform(1.1,9.9)

    # attempts to make unauthorized system modifications
    if attempts_system_modifications(file_path):
        score += random.uniform(2.1,5.3)

    # file uses non-standard encryption algorithms
    if uses_non_standard_encryption(file_path):
        score += random.uniform(0,7.2)

    # file alters or deletes critical system files
    if alters_system_files(file_path):
       score += random.uniform(3.1,4.2)


    # file has a high entropy value indicating potential obfuscation
    # if has_high_entropy(file_path):
    #     score += random.uniform(45.1,53.2)

    if score > 100:
        score = 100.0

    if file_path.endswith((".png")):
        score = 0
    # score += random.uniform(1.1,6.7)

    return score


#FUNCS
def contains_suspicious_imports(file_path, suspicious_imports):
    try:
        pe = pefile.PE(file_path)
        import_table = pe.DIRECTORY_ENTRY_IMPORT

        for entry in import_table:
            for imp in entry.imports:
                if imp.name.decode('utf-8') in suspicious_imports:
                    return True

    except Exception as e:
        pass  

    return False

def has_valid_signature(file_path):
    try:
        pe = pefile.PE(file_path)
        if pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress > 0:
            return True

    except Exception as e:
        pass  

    return False


def has_excessive_compression(file_path):
    try:
        with open(file_path, 'rb') as file:
            data = file.read()
            decompressed_data = zlib.decompress(data)
            if len(decompressed_data) < len(data) / 2:
                return True
    except Exception as e:
        pass  

    return False

def has_obfuscated_code(file_path):
    try:
        with open(file_path, 'r', errors='ignore') as file:
            content = file.read()
            if 'eval(' in content or 'b64decode(' in content:
                return True
    except Exception as e:
        pass  

    return False

def has_uncommon_file_header(file_path):
    try:
        with open(file_path, 'rb') as file:
            file_header = file.read(2)
            if file_header != b'MZ':
                return True
    except Exception as e:
        pass  

    return False


def connects_to_suspicious_ips(file_path):
    try:
        with open(file_path, 'r', errors='ignore') as file:
            content = file.read()
            if '192.168.0.1' in content or 'attacker.com' in content:
                return True
    except Exception as e:
        pass  

    return False

def attempts_system_modifications(file_path):
    try:
        with open(file_path, 'r', errors='ignore') as file:
            content = file.read()
            if 'HKEY_LOCAL_MACHINE' in content or 'regedit' in content:
                return True
    except Exception as e:
        pass  

    return False
#tbd
def uses_non_standard_encryption(file_path):
    try:
        with open(file_path, 'r', errors='ignore') as file:
            content = file.read()
            if 'non_standard_encryption()' in content:
                return True
    except Exception as e:
        pass  

    return False
#tbd
def alters_system_files(file_path):
    try:
        with open(file_path, 'r', errors='ignore') as file:
            content = file.read()
            if 'delete_system_file()' in content:
                return True
    except Exception as e:
        pass  

    return False

def has_high_entropy(file_path):
    try:
        with open(file_path, 'rb') as file:
            data = file.read()
            entropy = calculate_entropy(data)
            if entropy > 7.0:
                return True
    except Exception as e:
        pass  
    return False

def calculate_entropy(data):
    if not data:
        return 0

    entropy = 0
    data_length = len(data)
    for byte in range(256):
        prob = float(data.count(byte)) / data_length
        if prob > 0:
            entropy -= prob * math.log(prob, 256)
    return entropy

